\documentclass{article}
\usepackage{amsmath, amsfonts, amsthm, geometry, mathtools}

\geometry{
a4paper,
total={8.5in,12in},
left=.5in,
right=.5in,
top=.3in,
bottom=1in,
}

\newcommand{\horrule}[1]{\rule{\linewidth}{#1}}
\title{
    \normalfont \normalsize
    \textsc{Archiver Notes} 
    \horrule{0.5pt} \\
    \huge Introduction to Algorithm \\
    \small Part I: Chapter 1\\
    \horrule{2pt} \\
}

\author{Entropy Archive}
\date{\normalsize 29 April 2015} 
\begin{document}
\maketitle
\section*{Chapter 1}
Basic definition of what an algorithm does, examples of their use and one that
are covered within the confines of the book. They define a correct algorithm is
said to be correct if it halts with correct output. An interesting note about
incorrect algorithms being useful. An example is presented in chapter 31.
Parallelism , a subject that particularly interests, will be covered in chapter
27. Hopefully I get there by the end of the summer.\\ 

\textit{Question from 1.1}
\begin{description}
\item[1.1-1] 
A real world example of 'convex hull' would be useful for automatically created
maps that contain all desired locations. 
\item[1.1-2]
In the real world, complexity to implement an algorithm is always an issue. In
battery powered devices, optimization for battery usage may be more desirable
rather than speed.   
\item[1.1-3] A singularly linked list only points to the next item in the list.
A doubly linked list points to the next item and previous item.The doubly can
move forward and backwards but requires more memory to store the extra pointer.
\item[1.1-4] The traveling-salesman and shortest path are not the same problem.
Both aim to minimize distances, but the distance they are attempting to
minimize are not the same. The traveling-salesman is creating a minimal
distance of a loop that visits each node exactly once. This problem is NP hard.
The shortest path is minimization of distance between two points. This is
solvable problem. 
\item[1.1-5] Compilers want to both compile and optimize code. To do this, they
require both efficient and correct algorithms. Outputting incorrect code that
does not follow standards is unacceptable. If a compiler produce slow code,
customers would not be happy. To keep a completive, they must produce both
correct and efficient code. Quick scrips to complete a simple task such
scraping a websites for information doesn't need to have efficient code. They
are usually 'good' enough if they perform the task quick enough.    
\end{description}


   
\end{document}

